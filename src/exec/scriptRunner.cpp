#define WIN32_LEAN_AND_MEAN
#include "../console/log.hpp"
#include "../tcatlib/api.hpp"
#include "scriptRunner.hpp"
#include <algorithm>
#include <fstream>
#include <stdexcept>
#include <windows.h>

namespace exec {

const char *scriptRunner::kSuccessSentinel = "***INSTALL SUCCESSFULL***";
const char *scriptRunner::kErrorSentinel = "***ERROR: ";

autoDeleteFile::autoDeleteFile(const std::string& path, bool armed)
: m_path(path)
, m_shouldDelete(armed)
{
}

autoDeleteFile::~autoDeleteFile()
{
   if(m_shouldDelete)
      ::DeleteFile(m_path.c_str());
}

const std::string& autoDeleteFile::path() const
{
   return m_path;
}

void autoDeleteFile::enableDelete()
{
   m_shouldDelete = true;
}

void autoDeleteFile::cancelDelete()
{
   m_shouldDelete = false;
}

debugArtifact::debugArtifact(console::iLog& l)
: m_log(l)
, m_armed(true)
{
}

debugArtifact::~debugArtifact()
{
   if(!m_armed)
      return;

   m_log.writeLn("retaining files because of errors");
   for(auto it=m_files.begin();it!=m_files.end();++it)
   {
      auto name = m_names[*it];
      (*it)->cancelDelete();
      m_log.writeLn("   %s - %s",name.c_str(),(*it)->path().c_str());
   }
}

void debugArtifact::add(autoDeleteFile& f, const std::string& desc)
{
   m_files.push_back(&f);
   m_names[&f] = desc;
}

void debugArtifact::enableDelete()
{
   m_armed = false;

   for(auto it=m_files.begin();it!=m_files.end();++it)
      (*it)->enableDelete();
}

void scriptRunner::addVar(const char *pName, const char *pValue)
{
   std::string name = pName;

   // convert to uppercase
   std::transform(name.begin(),name.end(),name.begin(),::toupper);

   // spaces and hyphens to underscores
   std::replace(name.begin(),name.end(),' ','_');
   std::replace(name.begin(),name.end(),'-','_');

   // prepend gordian prefix
   name = std::string("g") + name;

   m_vars[name] = pValue;
}

void scriptRunner::execute(const char *_path, console::iLog& l)
{
   std::string path = _path;
   path += ".bat";

   autoDeleteFile log(startLogFile(path),false);
   autoDeleteFile wrapper(generateWrapperFile(path,log.path()),false);
   debugArtifact dbg(l);
   dbg.add(log,"log output");
   dbg.add(wrapper,"wrapper script");

   runWrapper(wrapper.path());
   checkLog(log.path());

   dbg.enableDelete();
}

std::string scriptRunner::chooseTempPath()
{
   char path[MAX_PATH];
   if(::GetTempPathA(MAX_PATH,path)==0)
      throw std::runtime_error("internal software error");

   char fullPath[MAX_PATH + 1];
   if(::GetTempFileNameA(path,"cdw_G",0,fullPath)==0)
      throw std::runtime_error("internal software error");

   return fullPath;
}

std::string scriptRunner::startLogFile(const std::string& scriptPath)
{
   autoDeleteFile log(chooseTempPath(),true);
   FILE *pLog = ::fopen(log.path().c_str(),"w");
   if(!pLog)
      throw std::runtime_error("failed to create log file");
   ::fprintf(pLog,"[gordian] log file started for user script %s\n",scriptPath.c_str());
   ::fclose(pLog);
   log.cancelDelete();
   return log.path();
}

std::string scriptRunner::generateWrapperFile(const std::string& scriptPath, const std::string& logPath)
{
   autoDeleteFile basePath(chooseTempPath(),true); // I don't actually want the non-batch file one
   autoDeleteFile wrapper(basePath.path() + ".bat",true);
   FILE *pWrapper = ::fopen(wrapper.path().c_str(),"w");
   if(!pWrapper)
      throw std::runtime_error("failed to create wrapper script");

   ::fprintf(pWrapper,"@echo off\n");
   ::fprintf(pWrapper,"\n");
   ::fprintf(pWrapper,"REM this file is auto-generated by gordian\n");
   ::fprintf(pWrapper,"\n");
   ::fprintf(pWrapper,"setlocal\n");
   ::fprintf(pWrapper,"set gLOG=\"%s\"\n",logPath.c_str());
   ::fprintf(pWrapper,"set gSUCCESS=%s\n",kSuccessSentinel);
   ::fprintf(pWrapper,"set gERROR=%s\n",kErrorSentinel);

   for(auto it=m_vars.begin();it!=m_vars.end();++it)
      ::fprintf(pWrapper,"set %s=%s\n",it->first.c_str(),it->second.c_str());

   ::fprintf(pWrapper,"\n");
   ::fprintf(pWrapper,"echo [gordian] wrapper script entering user script>>%%gLOG%%\n");
   ::fprintf(pWrapper,"call \"%s\" >> %%gLOG%% 2>&1\n",scriptPath.c_str());
   ::fprintf(pWrapper,"echo [gordian] user script returned to wrapper script; done>>%%gLOG%%\n");
   ::fclose(pWrapper);

   wrapper.cancelDelete();
   return wrapper.path();
}

void scriptRunner::runWrapper(const std::string& wrapperPath)
{
   STARTUPINFO si;
   ::memset(&si,0,sizeof(STARTUPINFO));
   si.cb = sizeof(STARTUPINFO);

   PROCESS_INFORMATION pi;
   ::memset(&pi,0,sizeof(PROCESS_INFORMATION));

   std::string command = "cmd.exe /c \"";
   command += wrapperPath;
   command += "\"";

   BOOL success = ::CreateProcessA(
      NULL,                               // lpApplicationName,
      const_cast<char*>(command.c_str()), // lpCommandLine,
      NULL,                               // lpProcessAttributes,
      NULL,                               // lpThreadAttributes,
      FALSE,                              // bInheritHandles,
      0,                                  // dwCreationFlags,
      NULL,                               // lpEnvironment,
      NULL,                               // lpCurrentDirectory,
      &si,                                // lpStartupInfo,
      &pi                                 // lpProcessInformation
   );
   if(!success)
      throw std::runtime_error("failed to create process");

   ::WaitForSingleObject(pi.hProcess,INFINITE);

   ::CloseHandle(pi.hProcess);
   ::CloseHandle(pi.hThread);
}

void scriptRunner::checkLog(const std::string& logPath)
{
   std::ifstream file(logPath.c_str());
   if(!file.good())
      throw std::runtime_error("internal software error");

   bool foundSuccess = false;

   while(true)
   {
      std::string line;
      std::getline(file,line);
      if(!file.good())
         break;

      if(::strncmp(line.c_str(),kSuccessSentinel,::strlen(kSuccessSentinel))==0)
         foundSuccess = true;

      if(::strncmp(line.c_str(),kErrorSentinel,::strlen(kErrorSentinel))==0)
         throw std::runtime_error(line.c_str() + ::strlen(kErrorSentinel));
   }

   if(!foundSuccess)
      throw std::runtime_error("user script completed without declaring success; premature halt?");
}

tcatExposeTypeAs(scriptRunner,iScriptRunner);

} // namespace exec

tcatImplServer();

BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID) { return TRUE; }
